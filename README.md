## **Page Overview**
My name is Hannah Frederick and this page serves as my CS499 Computer Science Capstone, showcasing my growth while in the Computer Science program at SNHU. My skills and abilities will displayed through the revision of two artifacts highlighting growth in three key categories: Software Design and Engineering, Algorithms and Data Structures, and Databases.

## **Self-Assessment**
FIX ME NEEDS ADDED

## **Code Review**
FIX ME ADD CODE REVIEW AND DESCRIPTION

## **Software Design and Engineering**

#### **Original Project File**
[Link to Original CS 320 Project](https://github.com/hfrederick01/hfrederick01.github.io/tree/main/CS%20320%20Project)

#### **Enhanced Project File**
[Link to Enhanced CS 320 Project](https://github.com/hfrederick01/hfrederick01.github.io/tree/main/CS%20320%20Enhancement)

#### **Selected Artifact**
For the Software Design and Engineering category, I chose to enhance my final project from CS 320, created in May of 2025. This project was developed for a mobile application client who needed a program to utilize in-memory data structures to store contact, task, and appointment information. Additionally, the program needed to meet various client requirements involving adding, deleting, and updating different aspects of a contact, task, or appointment. Finally, this program needed to incorporate unit testing to verify all of the specified requirements were met and functioning properly.

### **Justification of Selecting Artifiact**
I selected this artifact to include in my ePortfolio because it was a project that was originally not written in Python. I would like to be a healthcare data analyst, and I know that Python is a popular language for data analysts to use. As I draw closer to the end of my degree program, I would like to start practicing the skills I will need in my desired career field, and I have not coded in Python in quite some time so enhancing the project by transferring it from Java into Python is great practice. This enhancement allows for a more diverse audience to utilize the program as Python is a language that’s utilized by people both in and out of the computer science field. Additionally, I did not have any experience with unit testing in Python, so this presented an opportunity to learn and refine this skill. The implementation of unit testing displays knowledge of well-founded techniques, skills, and tools needed when coding an accurate and efficient program. Also, the use of object-oriented programming to modularize the functioning parts of the program to make it more efficient and reusable displays skills of utilizing best practices when developing a program. Similarly, choosing to not use object-oriented programming for the testing files displays my understanding of Pytest and the way it was designed to be implemented. Finally, my naming of variables, overall structure, spacing, and comments further demonstrate my ability to follow general best practices when developing a program in order to create simple, clean, and clear code.

### **Reflection of Enhancing Artifiact**
While enhancing and modifying the artifact I ran into a few challenges. To begin, I chose to develop this project in Jupyter Notebook as a collection of .ipynb files so that I could frequently run the code, catch any small errors, and debug as I went. I started with the files that run the program, so when I got to the testing files, I was having a hard time properly importing the notebooks. After some reading, I learned that converting the .ipynb files into .py files would make the importing process easier. After making this switch I was able to easily import my classes for testing. There was also a learning curve with implementing Pytest unit testing as I had never done it before. Originally, I planned to have one generic error message of that would be thrown if a variable was either null or too long. For example, if the requirements for a contact ID were not met, the error message “Invalid contact ID” would be thrown. I soon discovered that in order to properly use Pytest I would have to be more specific with the errors that were thrown as each message in my Contact, Task, and Appointment constructors had to exactly match the error thrown in each testing method. This meant for all of my constructors, including the contact ID example mentioned earlier, I had to change my constructor to throw specific messages such as “Contact ID null” or “Contact ID too long.” A final smaller challenge I faced was remembering the correct naming conventions for Python. I had grown used to coding in camel case but remembered snake case is the preferred naming convention for Python as I was researching how to use Pytest, so I had to go through and correct my method and variable names.

## **Algorithms and Data Structure**
FIX ME ADD ONCE FEEDBACK IS RECEIVED

## **Databases**
FIX ME ADD ONCE FEEDBACK IS RECEIVED
